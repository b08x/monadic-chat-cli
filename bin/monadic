#!/usr/bin/env ruby

# frozen_string_literal: true

require_relative "../lib/monadic_chat"
MonadicChat.require_apps

module MonadicApp
  include MonadicChat

  PROMPT_SYSTEM.on(:keypress) do |event|
    case event.key.name
    when :ctrl_p
      PROMPT_SYSTEM.trigger(:keyup)
    when :ctrl_n
      PROMPT_SYSTEM.trigger(:keydown)
    end
  end

  def self.run
    wid = 60
    mon = " /M/O/N/A/D/I/C/"
    chat = " /C/H/A/T/ "
    hpad = " " * ((wid - (mon.size + chat.size) - 1) / 2).to_i
    cpad = ""
    montitle = PASTEL.on_green.bold(mon)
    chattitle = PASTEL.on_green.bold(chat)
    title = "#{hpad}#{montitle}#{cpad}#{chattitle}#{hpad}"
    title += ((wid - (mon.size + chat.size)) % 2).zero? ? "" : " "
    subtitle = PASTEL.bold("Command Line Interface for NLP Completion API".center(wid, " "))
    version = "Version: #{VERSION}".center(wid, " ")
    vpad = " " * wid

    banner = <<~BANNER
      #{PASTEL.on_blue(vpad)}
      #{PASTEL.on_cyan(vpad)}
      #{PASTEL.on_cyan(title)}
      #{PASTEL.on_cyan(vpad)}
      #{PASTEL.on_cyan(subtitle)}
      #{PASTEL.on_cyan(vpad)}
      #{PASTEL.on_cyan(version)}
      #{PASTEL.on_cyan(vpad)}
      #{PASTEL.on_blue(vpad)}
    BANNER

    mode = "normal"
    openai_completion = nil
    parameter = ""

    loop do
      MonadicChat.clear_screen
      TTY::Cursor.clear_screen_down
      # print TTY::Box.frame banner.strip
      print "\n", banner.strip, "\n\n"

      openai_completion ||= MonadicChat.authenticate

      parameter = PROMPT_SYSTEM.select(" Select app:",
                                       per_page: 10,
                                       cycle: true,
                                       filter: true,
                                       default: 1,
                                       show_help: :never) do |menu|
        APPS.each do |app|
          next unless TEMPLATES["#{mode}/#{app}"]

          desc = eval("#{app.capitalize}::DESC", binding, __FILE__, __LINE__)
          menu.choice "#{BULLET} #{PASTEL.bold(app.capitalize)} #{desc}", app
        end

        case mode
        when "research"
          menu.choice "#{BULLET} #{PASTEL.bold("Mode")} Switch from #{PASTEL.bold.red("Research")} (current) to #{PASTEL.bold.green("Normal")}", "mode"
        when "normal"
          menu.choice "#{BULLET} #{PASTEL.bold("Mode")} Switch from #{PASTEL.bold.green("Normal")} (current) to #{PASTEL.bold.red("Research")}", "mode"
        end

        menu.choice "#{BULLET} #{PASTEL.bold("Readme")} Open Readme/Documentation", "readme"
        menu.choice "#{BULLET} #{PASTEL.bold("Quit")} Quit/Exit/Bye", "exit"
      end

      begin
        case parameter
        when "mode"
          mode = mode == "normal" ? "research" : "normal"
          next
        when "readme"
          MonadicChat.open_readme
          next
        when "exit"
          MonadicChat.clear_screen
          print "#{PASTEL.bold("Bye!")}\n"
          exit
        else
          MonadicChat.clear_screen
          eval(parameter.capitalize, binding, __FILE__, __LINE__).new(openai_completion, research_mode: mode == "research").run
        end
      rescue StandardError
        next
      end
    end
  end
end

MonadicChat.clear_screen
MonadicApp.run
